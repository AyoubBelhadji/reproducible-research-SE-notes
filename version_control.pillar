!! Version Control with Git and Github

Version control systems (VCSs) are one of the cornerstones of reproducibility.
Informally speaking, a VCS works as a database that saves versions of your project.
That is, it will store all changes you will do (as soon as you instruct it to do so).
Thus, the main feature of a VCS is that it allows us to freeze our project at any point in time, and then query and recover old versions as they were.
These features will improve our day-to-day work with two more direct benefits: they remove fear to change and allow us to clean up unused and old code.

Unexperienced developers fear changing some parts of their project.
This happens mainly when developers cannot guarantee that the changed code is right or will work properly.
The absence or the complexity of testing feeds this fear even more.
However, when using a VCS, making mistakes is not painful anymore.
We can come back to any saved version and ignore or discard potentially wrong versions.

Finally, a VCS does not only store our versions but other useful meta-data.
For example, it saves the timestamp of any change, its author, and some useful comments.
This avoids adding this kind of identifying data in the code, leaving the code more readable and single-purpose, while we let the VCS automatically manage and label changes.

In this chapter we will explore the basics of VCSs with Git and Github. We have chosen Git because of its popularity nowadays, and Github because it is one of the most prominent platforms for Git. However, most of the concepts can be easily applied to other VCSs and platforms. This chapter will start with the setup of a repository, how to store changes into it and how to investigate/query them. The second part of the chapter will show some other advanced features such as tagging and branches, including merging.

!!! Amateurs, engineers and researchers: What are VCSs useful for? 

VCSs are a technology that are mostly used to store programming source code.
However, they can most of the times store any kind of files: from text files to binary files.
This means that we can use VCSs to version text documents, pictures, websites, pdfs, excel files or others.

Software engineers use VCSs to manage their software projects.
They store the project's versions to store all file changes in (at a minimum) a daily basis.
They may use it generally to store the project's documentation.

These technologies can be, however, of value in other fields, particularly in research, where the reproducibility of experimental results and documents is important.
Researchers can use VCSs to version experimental setups and their results, to track the advance and changes of their research papers.

While this chapter will cover the basics of VCSs using Git, the workflow specific chapters will show how to apply these techniques in specific scenarios: reproducible code, reproducible papers, reproducible documentation.

!!! Setting up a Repository

A Git repository is like a database storing changes. In the modern world, good practice is to store the main repository in a remote machine, usually a server hosted in our company/university or in the cloud. We avoid storing our main repository only in our machine, as losing our machine would then result in losing our project. As we shall see, a remotely-stored Git repository advantageously replaces manual backups.

This chapter will assume you have Git already installed in your machine, and that you're using a *nix operating system. An appendix at the end will give some details on different setups and installation procedures.

The easiest way to start a repository is to create it directly online. If you have a Github account, get yourself to the "New Repository" action (usually within the menu using the "+" symbol) and you will see the form in Figure *@new_repo_github*. Follow the form and create your repository

+Creating a New Repository in Github>figures/new-repository-github.png|label=new_repo_github+

!!!! Creating an SSH key

To be able to use your repository, remotely, you need to setup the Github credentials.
Otherwise, Github will reject any operation against your repository.
Such a setup requires the creation and uploading of SSH keys.

An SSH key works as a lock: a key is actually a pair of a public and a private key. The private key is meant to reside in your machine and not be published at all. A public key is meant to be shared with others to prove your identity. Whenever you want to prove your identity, SSH will exchange messages encrypted with your public key, and see if you are able to decrypt it using your private key.

To create an SSH key, in *nix systems you can simply type in your terminal

[[[language=bash
$ ssh-keygen -t rsa -b 4096 -C "your_email@some_domain.com"
]]]

Follow the instructions in your terminal such as setting the location for your key pair (usually it is ==$HOME/.ssh==) and the passphrase (a kind of password). Finally, you'll end up with your public/private pair on the selected location. It is now time to upload it to Github.

Connect yourself to your Github settings (usually https://github.com/settings/profile) and go to the "SSH and GPG keys" menu. Import there the contents of your public key file. You should be now able to use your repository.


@@note Alternatively, you can follow the *instructions on Github>https://help.github.com/articles/connecting-to-github-with-ssh/*.

!!!! Cloning the Repository

Git, constrastingly to other VCSs, is a distributed VCS. This means that you work not only against the remote repository but also you can work locally. To support that, Git makes a ""local copy"" of the repository in your machine. To create such a copy, the usual Git command is ""clone"".

[[[language=bash
$ git clone git@github.com:[your_username]/[your_repo_name].git
]]]

When this command finishes, it will create a directory named as your repository (your_repo_name).
This directory contains the files you will work on, and it is where you will issue your Git commands later on.
You are now ready to go.

@@todo explain what happened and what was created!

!!! Understanding Git Basics

Before going on with the reproducibility concerns that brought you here to read this chapter and even before continuing with practical Git commands, we will dive a bit into Git concepts.
Understanding a bit how Git works is useful when doing some more complicated stuff such as merging and branching.
If you already know what is a Git commit, a Git reference and how the graph of Git objects is managed, you can skip this section.

!!!! Dissecting a Git Repository

Before starting explaining what is a commit, what is a branch, and so on, let's start easy by understanding the parts that compose our Git repository.
When you create a Git repository as we did in the last section, or you clone an old repository that already has some files in it, you will find that there is more than meets the eye. A Git repository has usually three core collaborating components: the working copy, the repository, and the remotes. You can see an schematics on Figure *@repository_structure*.

+Git repository structure>figures/repository-structure.pdf|width=90|label=repository_structure+

What you usually see in your disk when you clone is not actually the Git repository but the ""working copy"".
The working copy is the directory where your files are, where you work and apply modifications.
It is called a working ""copy"" because what you see is actually a copy of what is in the repository.
The working copy is a write-able copy: you can freely modify it, break it, add new things or remove things.

Actually, you can do whatever change you want in your working copy, that Git will not take it into account, at least not automatically.
Once your changes are ready, you have to commit them into your repository to store them in your repository.
A commit will take your changes, freeze them, and store them in the local database.
Just for the curious ones, the local database (also known as ""the BLOB"" in the Git jargon) is stored inside your working copy, in a hidden directory called "".git"".

The commits you create from your changes live only inside your machine by default.
If you want to share your commits with others, or to import commits from some fellow colleague, you have to interact with a remote repository (also called just remote).
A remote is a distant Git repository that you will synchronize with your local one from time to time (this is where the famous pull and push come into play!).

Of course, this is an utterly simplified scenario.
You could have a repository without a working copy.
And your repository may have many remotes to synchronize with.
But we will get into more complex stuff early on, no need to rush now.

!!!! A history-aware transactional database?

As we explained before, we usually work on the working copy, modifying our files and directories.
Once we finished some work, we can freeze it and store it in the repository.
That's what we call a ""commit"".

From this perspective, a Git repository works as a transactional database.
You are working on the changes of your disk, but they will not be effectively applied until you finish your transaction.
Finishing your transaction is done, as in the database world, using the ""commit"" command.
The result of this transaction is to create a new commit object in the Git repository.
This commit object will contain an id (usually a hash such as ==7ba52e5==) plus all changes we wanted to apply.

Git will store your last changes but also remember the entire history of changes you did.
It keeps a list of all changes you did so you can do some nice stuff like for example:

- come back in time to recover some old change
- trace the changes in a file to see who (and why!) did a change
- analyze your repository and do some archeology, to see how your project evolved

!!!! It's a just graph of commits

The history of commits we explained before is not stored in a list form but in a graph form.
A commit is a node connected to other commits by ""parenthood"".
A commit is said to be parent of another commit if it is the exact previous version.
In other words, when we create a new commit, the parent of our new commit is the previous commit.
A commit is said to be an ancestor of another commit if it preceeds it in history.
Moreover, a commit can have one or many parents, and many commits can have the same commit as parent.

+Graph of commits>figures/commit-graph.pdf|width=65|label=commit_graph+

For instance, take a look at the schema of a typical commit graph represented in Figure *@commit_graph*.
- Commit ==a4153b1== is the first commit in the graph, with no parents. A commit with no parents represents the first commit in a repository, when no previous history was available.
- Commit ==35ac17f=='s parent is ==a4153b1== and commit ==a4153b1=='s parent is ==7ba52e5==.
- Commit ==b01aba4=='s parent is also ==a4153b1==.
- Commit ==b8bfed7== has two parents: ==7ba52e5== and b01aba4.

You may be asking yourself how can we arrive to such a situation.
In short, a commit that is parent of many commits is creating an alternative history line: it is the result of a ""branch"" operation.
Likewise, a commit that has many parents is joining two histories: it is the result of a ""merge"" operation.

!!!! Naming commits with references

You probably noticed that referring to commits by their id is awkward.
Commit ids are generated automatically as hashes that avoid duplications as much as possible.
However, they are not handy to work on a daily basis since they are hard to remember and type.

To solve this, Git provides a second kind of objects: Git references.
A Git reference is like a label that you put on a commit, to be able to identify that commit by a much much simpler name afterwards.
For example, you can name a commit as ""release 1.0"" or you can name it as ""current development commit"".

+Git references>figures/references.pdf|width=80|label=references+

As we show in Figure *@references*, there are two main kinds of references in Git:
- ""tags"": tags are fixed labels that once created are not meant to be removed or moved. They are useful for doing releases: people will expect that a release does not change, otherwise they cannot depend on it.
- ""branches"": branches are transferable labels that can be moved from commit to commit. They are used to maintain the different history lines of your project.

Another special reference, called ""HEAD"" is internally used by Git to know what is our current working branch.
While it would look like an implementation detail, knowing that ""HEAD"" is there can save you many headaches as we will see later.

Now that you have built some strong conceptual Git muscles, we can continue in the next sections with some practical Git.
Do not hesitate to come back to these sections to refresh some of the basics.
As with any sport or discipline, understanding and practicing the basics is really important, since everything else is based on them.

!!! Commit! Save your work!

Let's imagine I was working on my project for a couple of hours.
As a result, I have two new files with some contents on it: a README.md file with some explanations and a txt file with some project information in it.

[[[language=bash
$ ls
project.txt README.md
]]]

We want now to save those files in our Git repository now, so if anything happens, we can always recover our work to this point.
Such operation is called a ""commit"", and it basically means that we are going to move some content from our working copy to our local repository, as it is shown in Figure *@commit_in_workflow*.

+Commit is an operation that stores things from your working copy into your local repository>figures/commit_in_workflow.pdf|width=90|label=commit_in_workflow+

One of the things that we can do first is to check what Git knows about these files:

[[[language=bash
$ git status
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	README.md
	project.txt

nothing added to commit but untracked files present (use "git add" to track)
]]]

Git tells us that we are doing an initial commits, and that there are two files (==README.md== and ==project.txt==) that it doesn't know yet, they are untracked.
Then it tells us that it is not tracking any file and that we need to do a ==git add== to track them.

To make it simple, you can see this whole ""tracking"" story as going to the supermarket.
If you want to buy something from the supermarket, you have take whatever you want first and put it in your basket.
Then, you go to the cashier, you pay and take your things home.
Now imagine that passing through the cashier to pay is equivalent to do a commit command.
This means that first you need to add stuff to your c!

Adding stuff to your bag (or tracking files) is done through the add command.
Only what is added/tracked will be committed.
Let's proceed to track those files and see what is the status of our repository afterwards.

[[[language=bash
$ git add README.md
$ git add project.txt
$ git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   README.md
	new file:   project.txt
]]]

Now Git says that our two new files will be committed.
Let's also notice that it says that we are on a branch called master.
Let's now proceed to commit to save our changes in the repository.
We can do that by using the commit command with the ==m== option to specify a message:

[[[language=bash
$ git commit -m "first version"
[master (root-commit) 37adf4e] first version
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 README.md
 create mode 100644 project.txt
]]]

What the commit command is doing behind is to create a new node in our history graph.
Moreover, it will update the master branch label to point to this new commit.
The commit graph in this case will look as in Figure *@commit_graph_1*.

+History graph after our first commit>figures/commit_graph_1.pdf|width=65|label=commit_graph_1+

If we see the status of our repository after the commit we will also see that it changed.
There is nothing to commit:

[[[language=bash
$ git status
On branch master
nothing to commit, working directory clean
]]]

If we repeat the process, i.e. we apply a change to one of our files, add and commit our commit graph will change again.
A new commit with a new commit id will be created having as parent our previous commit.
The master branch label will be updated and point to this new commit.
The commit graph in this case will look as in Figure *@commit_graph_2*
Notice how our old commit is still there, but he's accessible as the parent of our new commit.

[[[language=bash
$ git add README.md
$ git commit -m "Adding a title"
[master 0c0e5ff] Adding a title
 1 file changed, 1 insertion(+)
]]]

+History graph after our second commit>figures/commit_graph_2.pdf|width=65|label=commit_graph_2+

!!!! Discarding your changes

It arrives the time for every woman/men to make mistakes and want to discard them.
Doing so may be dangerous, since once discarded you will not able to recover your changes.
It is however possible to instruct Git to do so.
For it, there are two Git comments that will perform the task for you and when combined they will completely discard every dirty file and directory in your repository:
==git reset== and ==git clean==

[[[language=bash
$ git reset --hard
$ git clean -df
]]]

The reason for needing two commands instead of one relies on the fact that Git has several staging areas (such as the ones used to keep the tracked files), which we usually would like to clean when we discard the repository. Of course, experienced readers may search why they would need both in Git's documentation.

!!! Exploring the History

!!!! The ==git log== command
The commit graphs we have shown so far are not evident at all while when we use the ==git status== command.
There is however a way to ask Git about them using the ==git log== command.

[[[language=bash
$ git log
commit 0c0e5ff55b56fe8eabc1661a1da64b41f9d74472
Author: Guille Polito <guillermopolito@gmail.com>
Date:   Wed Mar 21 15:37:32 2018 +0100

    Adding a title

commit 37adf4eaa945cbd7460991f88bff5aa902db06ce
Author: Guille Polito <guillermopolito@gmail.com>
Date:   Wed Mar 21 14:02:43 2018 +0100

    first version
]]]

==git log== prints the list of commits in order of parenthood.
The one on the top is the most recent commit, our last commit.
The one below is its parent, and so on.
As you can see, each commit has an id, the author name, the timestamp and its message.

We can also ask Git what are the changes introduced in a particular commit using the command ==git show==.

[[[language=bash
$ git show 0c0e5ff55b56fe8eabc1661a1da64b41f9d74472
commit 0c0e5ff55b56fe8eabc1661a1da64b41f9d74472
Author: Guille Polito <guillermopolito@gmail.com>
Date:   Wed Mar 21 15:37:32 2018 +0100

    Adding a title

diff --git a/README.md b/README.md
index e69de29..cad05f1 100644
--- a/README.md
+++ b/README.md
@@ -0,0 +1 @@
+! a title
\ No newline at end of file
]]]

That will give us the commit description as in ==git log== plus a (not so readable) diff of the modified files showing the inserted, modified and deleted lines.
More advanced graphical tools are able to read this description and show a more user-friendly diff.

!!!! Seeing the history graph

Git's log provides a more graphish view on the terminal using some cute ascii art.
This view can be accesses through the ==git log \-\-graph \-\-oneline \-\-all== command.
Here is an example of this view for a more complex project.
In this view, stars represent the commits with their ids and commit messages, and lines represent the parenthood relationships.

[[[language=bash
$ git log --graph --oneline --all
* 4eb8446 Documenting
* e5a3e2e Add tests
* 680a79a Some other
| *   ed4854f Merge pull request #1137
| |\
| | * 9e30e37 Some feature
| * |   ba7f65c Merge pull request #1138
| |\ \
| | * | 31a40c4 Some Enhancement
| | |/
| * |   2d4698d Merge pull request #1139
| |\ \
| | * | 20c0ff4 Some fix
| | |/
| * |   ae3ec45 Merge pull request #1136
]]]

However, we are not always in the mood of using the terminal, or of wanting to decode what was done in ascii art.
There are tools that are more suitable to explore the history of a project, usually providing some nice graphical capabilities.
This is the case of tools such as SourceTree (Figure *@commit_graph_sourcetree*) or Github's network view (Figure *@commit_graph_github_network*).

+Example of SourceTree's commit graph view>figures/sourcetree_tree.png|label=commit_graph_sourcetree+
+Example of Github's commit graph view>figures/github_network_tree.png|label=commit_graph_github_network+

!!! Releasing your code with tags

When your project is in a stable state, it is often good to freeze it and put a name to that version.
That way, other users can load the frozen version using that well-known name, and also be sure that version will not change.
Freezing a version is particularly useful to reproduce a piece of sofware.
A frozen version can be reloaded exactly as it is right now but in some point in the future.
Thus, software that depends on a frozen version can also benefit from its stability.

In Git, releasing is done via tags.
A tag is a label that we put on a particular commit to be able to find it easily later on, so remember to put short, readable names to them.
One particular consideration about tags is that they are not meant to be modified, although you will find in Git's documentation that you have special operations (that we do not recommend) to do that.

To create a tag, use the command ==git tag== giving as argument a name for the tag and a descriptive message.
Usual tag names use semantic version conventions, prefixed with a v. For example version 1 would be ==v1.0.0==.

[[[language=bash
$ git tag -a v1.0.0 -m "First stable release"
]]]

You can afterwards list all your tags using the ==git tag== command without arguments:

[[[language=bash
$ git tag
v0.1.1-alpha
v1.0.0
]]]

Finally, if you want to recover the code that you tagged at some point, you can use the ==checkout== command with the name of your tag.

[[[language=bash
$ git checkout v1.0.0
Note: checking out 'v1.0.0'.

You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 0c0e5ff... Adding a title
]]]

When checking out a tag, Git tells you that we are in ''detached HEAD'' state.
And that whatever commit we do in this state will be lost unless we create a branch.
What happened here is that the ==checkout== command modified the ""HEAD"" reference to point to the commit pointed by the tag, instead of a branch. Figure *@detached-head* shows the commit graph for this particular case.

+Detached HEAD after checking out a tag>figures/dettached_head.pdf|width=65|label=detached-head+

!!!! Getting out of Detached HEAD

Detached head means no other than "HEAD is not pointing to a branch".
Being in a detached HEAD state is not bad in itself, but it may provoke loss of changes.
As a matter of fact, any commit that is not properly referenced by another commit or by another Git reference (tag, branch) may be garbage collected.

Git will not forbid you to commit in this state, but any new commit you create will only reachable if you remember the commit hash.
To get out of dettached HEAD, the easiest solution is to checkout a branch, as we will see in the next section.
Checking out a branch will set HEAD to point to a branch instead of a commit, saving you some HEADaches.

!!! Creating new history lines with branches

Branches in Git represent different histories.
As in one of science fiction time-travel theories, Git branching is equivalent to take one moment in time have several alternative time-lines from there.
Figure *@Branches* illustrates the idea, showing that you can have two different futures from commit _0c0e5ff_.

+History lines can be branched from a commit>figures/branches.pdf|width=65|label=Branches+

By default, a Git repository will include a single branch, called ""master"". Most people only need a single branch to work. However, it may be useful to split work in several branches as we will see later.
You can ask Git for the branches in the repository using the command ==git branch -v==.

[[[language=bash
$ git branch -v
* master  0c0e5ff Adding a title
]]]

This command shows all branches in the repository, one per line.
Then, for each branch it shows what commit it points, and the comment on that commit.

!!!! Creating a new branch

To create a new branch, we can use the command ==git branch [branch_name]== giving as argument the new branch name.
This will create a new branch from our current commit, the one that can be resolved from HEAD.
Figure *@new_branch* shows what happens in the graph view.

[[[language=bash
$ git branch development
]]]

+A new branch points by default to the same commit as the current branch>figures/new_branch.pdf|width=65|label=new_branch+

However, as we see in the graph view, creating a new branch does not modify HEAD.
Indeed, our current branch/commit did not move.
We will observe the same in the command line, if we ask the list of branches.
The branch master is marked with a star, indicating it is the actual branch.
And both branches point to the same commit.

[[[language=bash
$ git branch -v
* master      0c0e5ff Adding a title
  development 0c0e5ff Adding a title
]]]

To start working on our new branch, we just need to use the same ==checkout== command we used for tags.

[[[language=bash
$ git checkout development
Switched to branch 'development'
]]]

Or alternatively, we could have created our branch using the ==checkout -b== command, which performs a ==git branch== and a ==git checkout== one after the other.
Useful since these operations are usually done together most of the time.

[[[language=bash
# Instead of branch and then checkout
$ git checkout -b development
Switched to branch 'development'
]]]

Then, doing some work and creating a commit will only modify our current branch and leave ==master== as it was before.

[[[language=bash
$ touch somefile
$ git add somefile
$ git commit -m "added somefile"
[development b894b84] added somefile
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 somefile
$ git branch -v
   master      0c0e5ff Adding a title
 * development b894b84 added somefile
]]]

!!!! Diverging history

Now that we have done some work in a branch, we can make our branches diverge.
We only need to checkout another branch, existing or new, and start working from there.

[[[language=bash
$ git checkout master
Switched to branch 'master'
$ touch someotherfile
$ git add someotherfile
$ git commit -m "added someotherfile"
[master dc4a3e7] added someotherfile
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 someotherfile
$ git branch -v
 * master      dc4a3e7 added someotherfile
   development b894b84 added somefile
]]]

This change will create two diffent history lines, as shown in Figure *@Branches2*.
One history line represented by the ==master== branch, and another history line represented by the ==development== branch.

+Divergent history>figures/branches.pdf|width=65|label=Branches2+

!!! Merging history lines

The most complicated part of Git is not branching or commiting, but merging.
In our time-travel, time-line metaphores we said that branching is equivalent to open new time-lines.
Merging is the equivalent to join them into a single history.

The concept behind merging is not difficult.
Using the same idea of graph of commits that we used before, a merge can be represented as a commit that has several parents, thus joining several histories.
Figure *@merge* illustrates such a merge commit.

+Merging the history with a merge commit>figures/merge.pdf|width=65|label=merge+

However, as you see also in the picture, a merge commit will be referenced by one of the branches but not both.
In other words, a merge operation means that a first branch will be merged into a second one.
Thus the first one will remain intact.
To perform a merge we need to checkout the branch that will host the changes, and then use the ==merge== command with a branch name as argument.
The following example shows how we can merge the development branch into the master branch.

[[[language=bash
$ git checkout master
 ...
$ git merge development
[Merge made by the 'recursive' strategy.
 ...
 1 file changed, 0 insertions(+), 0 deletions(-)
 ...]
]]]

!!!! Managing Conflicts

When merging different history lines, things can go wrong if both history lines modified the same file or ressource.
Such a problem is also called a __conflict__.

To understand the issue, let's generate a conflict on purpose.
We can create two branches called ==future-1== and ==future-2== adding each the same file but with different contents:

[[[language=bash
$ git checkout -b future-1
$ echo "I'm in future-1" > conflicting.txt
$ git add conflicting.txt
$ git commit -m "Maybe will cause a conflict"

# Let's go back to master and redo the same in another branch
$ git checkout master

$ git checkout -b future-2
$ echo "I'm in future-2" > conflicting.txt
$ git add conflicting.txt
$ git commit -m "I'm sure it will cause a conflict!"
]]]

And then trigger a conflict when trying to merge:

[[[language=bash
# We are in future-2 so we will try to merge future-1
$ git merge future-1
Auto-merging conflicting.txt
CONFLICT (add/add): Merge conflict in conflicting.txt
Automatic merge failed; fix conflicts and then commit the result.
]]]

We see that as soon as we merge, Git tries to automatically merge the file ==conflicting.txt==.
It detects however a merge conflict that does not allow it to continue.
If we check Git's status, you will now see:

[[[language=bash
$ git status
On branch future-2
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both added:      conflicting.txt

no changes added to commit (use "git add" and/or "git commit -a")
]]]

Git tells us that ==conflicting.txt== is not merged and that we should fix it.
To continue working, we should resolve such a conflict, telling Git what version we want to keep.
Several solutions work: either we keep the version we had in ""future-2"", we keep the version incoming from ""future-1"", or we keep a can manually resolve the conflict and keep whatever version we want.

The easiest, non-thinking, way to merge is to open the conflicting file and resolve the conflict.
For example, if we open our ==conflicting.txt== file with a text editor we will see:

[[[
<<<<<<< HEAD
I'm in future-2
=======
I'm in future-1
>>>>>>> future-1
]]]

Git modified our file adding some ==<<<<<<<==, ==>>>>>>>== and ==\=\=\=\=\=\=\=== markers in our file.
What this markers delimit is the conflicts Git found.
As the first line says, the first region (what is between the ==<<<<<<<== and the ==\=\=\=\=\=\=\===) corresponds at the version that was in ""HEAD"" (i.e., ""future-2"").
As the last line says, the last region (what is between the ==\=\=\=\=\=\=\=== and the ==>>>>>>>==) corresponds to the version that was in ""future-1"".

To resolve the conflict, you should:
 - remove all the special markers
 - keep only the version you want (or edit it to be different)
 - add and commit the conflicting file
 
For example, let's say we wanted to keep the version in ""future-2"", we can edit the file leaving only

[[[
I'm in future-2
]]]

and then commit the resolved conflict:

[[[bash
$ git add conflicting.txt
$ git commit -m "Resolve conflict"
]]]

!!! Interacting with Remote Repositories

So far we have worked only on the repository that resides locally in our machine.
This means that mostly all of Git features are available without requiring an internet connection, making it suitable for working off-line (think on working on the train or with a constrained connection!). However, working off-line is a two-edged weapon: all your changes are captive in your machine.
While your changes are in your machine, nobody else can contribute or collaborate to them.
Moreover, losing your machine would mean losing all your changes too.

Keeping your changes safe means to synchronize them from time to time with a ""remote repository"".
A remote repository is a copy of your local repository that is stored remotely, that is, in somewhere else's machine.
This could be, for example, in your company's or university's server, the cloud, etc.

In this section we will see how to interact with remotes, how to configure them, and how to synchronize our local repository with them.

!!!! Git Remotes

!!!! Pushing your commits

!!!! Pulling new commits